#include<stdio.h>
#include<stdlib.h>//malloc 함수 사용
int main()
{
	int num, i, j;
	int x, y = 0;

	printf("원하는 크기를 입력하세요(홀수):");
	scanf("%d", &num);
	int **a; //이중포인터 선언
	a = (int**)malloc(num * sizeof(int*)); //기억공간을 동적으로 할당
	for (int i = 0; i < num; i++) {
		*(a + i) = (int *)malloc(num * sizeof(int));
	}
	int c = 1; //초기값 1

	for (i = num / 2, j = num / 2; j < num; i--, j++) //배열의 가운데부터 대입하다가 j가 num보다 커지거나 같으면 반복문을 마무리한다.
	{
		a[i][j] = c;
		c++;
	}
	i++; // 위에 for문에서 마지막으로 i--, j++을 하고 for문을 끝내기 때문에 원래상태로 되돌리기 위해 i++, j-- 를 한다.
	j--;

	for (x = 0, y = num; ; x += 2, y--) //한쪽 방향은 1씩 감소, 다른쪽 방향은 2씩 감소하기 때문
	{
		i++; //한칸 내리고 또 대입한다.
		for (; i < y; i++) // 한칸씩 내리면서 대입하고 i가 y보다 크거나 같으면 반복문을 마무리한다. 
		{
			a[i][j] = c;
			c++;
			if (c == (num*num) / 2 + 2) //  c가 (num*num) / 2 + 2이면 가까운 반복문을 탈출한다.
			{
				break;
			}
		}
		if (c == (num*num) / 2 + 2) //c가 (num*num) / 2 + 2이면 가까운 반복문을 탈출한다. 
		{
			break;
		}
		i--; //원래상태로 복구
		j--; //한칸 왼쪽으로 이동하여 대입한다.
		for (; x < j; j--)// 한칸씩 왼쪽으로 이동하면서 대입하고 x가 j보다 크거나 같으면 반복문을 마무리한다. 
		{
			a[i][j] = c;
			c++;
			if (c == (num*num) / 2 + 2)  //c가 (num*num) / 2 + 2이면 가까운 반복문을 탈출한다. 
			{
				break;
			}
		}
		if (c == (num*num) / 2 + 2)//c가 (num*num) / 2 + 2이면 가까운 반복문을 탈출한다. 
		{
			break;
		}j += 2; //원래상태로 복구하고 한칸 오른쪽으로 이동하고 한칸 위로 이동하여 대입한다.
		i--;
		for (; j < y - 1; i--, j++) // 오른쪽으로 한칸씩 이동하고 위로 한칸 씩 이동하여 대입하고 j가 y-1보다 크거나 같으면 반복문을 마무리한다.
		{
			a[i][j] = c;
			c++;
			if (c == (num*num) / 2 + 2) //c가 (num*num) / 2 + 2이면 가까운 반복문을 탈출한다. 
			{
				break;
			}
		}
		if (c == (num*num) / 2 + 2) //c가 (num*num) / 2 + 2이면 가까운 반복문을 탈출한다. 
		{
			break;
		}
		i++; //원래상태로 복구하고 한칸 아래쪽으로 이동하여 대입한다.
		j--;
	}
	for (i = num / 2 + 1, j = num / 2 - 1; j >= 0; i++, j--) // 1을 쓴 칸에서 아래로 한칸, 왼쪽으로 한칸가서 대입하기 시작한다.
	{
		a[i][j] = c;
		c++;
	}
	i--; //i++, j--를 하고 반복문을 마무리 하기 때문에 원래 상태로 복구하기 위하여 i--, j++을 해준다.
	j++;
	for (x = 0, y = num; ; x++, y -= 2) //한쪽은 한칸씩 감소하고, 다른 한쪽은 두칸씩 감소한다.
	{
		i--; // 한칸 위로 올려주고 대입을 시작한다.
		for (; i >= x; i--) //위로 한칸씩 올려주면서 대입하고 i가 x보다 작아질 때 까지 반복한다.
		{
			a[i][j] = c;
			c++;
			if (c == num * num + 1) //마지막 num * num 까지 배열에 대입해주고 c++을 했으므로 c가 num * num +1 이면 반복문을 마무리한다.
			{
				break;
			}
		} i++; //i--하고 반복문을 마무리 했으므로 원래 상태로 복구해주고 오른쪽으로 한칸 이동해준다.
		j++;
		if (c == num * num + 1) //마지막 num * num 까지 배열에 대입해주고 c++을 했으므로 c가 num * num +1 이면 반복문을 마무리한다.
		{
			break;
		}
		for (; j < y - 1; j++) //오른쪽으로 한칸 씩 이동하면서 대입해주고 j가 y-1과 같거나 커질 때까지 반복한다.
		{
			a[i][j] = c;
			c++;
			if (c == num * num + 1) {
				break;
			}
		}
		if (c == num * num + 1) {
			break;
		} j -= 2; //원래상태로 복구해주고 아래로 한칸, 왼쪽으로 한칸 가주고 대입을 시작한다.
		i++;
		for (; i < y - 2; i++, j--) //아래로 한칸, 왼쪽으로 한칸씩 이동하면서 대입하고 i가 y-2와 같거나 커질 때까지 반복한다.
		{
			a[i][j] = c;
			c++;
			if (c == num * num + 1) {
				break;
			}
		}
		if (c == num * num + 1) {
			break;
		}i--; //원래상태로 복구해준다.
		j++;
	}

	for (int i = 0; i < num; i++) //배열 출력
	{
		for (int j = 0; j < num; j++)
		{
			printf("%5d", a[i][j]); //여유있게 %5d로 5칸씩 주었다. a[i][j] 대신에 *(*(a+i)+j) 이렇게 표현해도 된다.
		}printf("\n");
	}

	for (int i = 0; i < num; i++) //할당 받은 메모리 반환
	{

		free(*(a + i)); //free(a[i]) 이렇게 표현해도 된다.
	}
	free(a);
}
